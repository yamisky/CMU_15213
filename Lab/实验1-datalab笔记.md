# 1 实验目的

这个作业的目的是让你更熟悉整数的位级表示。你将通过解决一系列编程“难题”来达到这个目的。虽然这些难题中的许多看起来相当人为和抽象，但在解决它们的过程中，你会发现自己更多地思考位级操作。简而言之，这项作业旨在通过一系列具有挑战性的练习，增强你对位操作和数据在二进制层面上表示的理解。

# 2 材料说明

1. **文件修改与提交**: 你需要修改的唯一文件是 `bits.c`，该文件包含了`14个编程谜题`的框架。你的任务是根据一套严格的编码规则完成每个函数。
2. **编码规则**: 
   - 对于整数谜题，你只能使用直线型代码（即不使用循环、函数调用或条件语句）。
   - 你只能使用以下八种C语言算术和逻辑运算符：`!`（非）、`~`（取反）、`&`（与）、`^`（异或）、`|`（或）、`+`（加）、`<<`（左移）、`>>`（右移）。
   - 某些函数对这些运算符的使用有进一步的限制。
   - 你不能使用超过8位的常量（范围从十六进制的0x00到0xFF）。
   - 对于整数谜题，你可以在`int`和`long`数据类型之间进行类型转换。
3. **基本假设**: 
   - `int`数据类型为32位。
   - `long`数据类型为64位。
   - 采用二进制补码表示有符号数据类型。
   - 有符号数据类型的右移操作是算术右移。
   - 对于一个w位的值，其移位数应在0到w-1之间。
4. **谜题说明**:
   - 文件中描述了你将在`bits.c`中解决的谜题。
   - 每个谜题都有一个“难度等级”和“最大操作数”限制。
   - 你可以参考`tests.c`中的测试函数，这些函数用于表达你的函数的正确行为，尽管它们不符合你的函数的编码规则。

# 3 实验内容概述

本实验就是不同的根据规则限定，完成11个函数，并通过规则语法检验和性能检验（统计运算符数量是否超标）。

谜题分为两大类型，如下：

### 3.1 位操作 (Bit Manipulations)

此部分描述了一系列操作和测试位集的函数。每个函数都有一个难度评级（得分）和最大操作数限制。请参考 `bits.c` 文件中的注释了解每个函数的预期行为。你也可以参考 `tests.c` 中的测试函数，这些函数用作你函数正确行为的参考，尽管它们不符合你函数的编码规则。所有参数和返回值均为 `long` 类型。

**位级操作函数**：

- `implication(x, y)`: 
  - 给定二进制输入 x 和 y（取值 0 或 1），返回命题逻辑中的 x → y，即假为 0，真为 1。
  - 评级 2，最大操作数 5。
- `leastBitPos(x)`: 
  - 返回标记最低有效位 1 的位置的掩码。如果 x 为 0，则返回 0。
  - 评级 2，最大操作数 6。
- `distinctNegation(x)`: 
  - 如果 x 和 -x 不同，则返回 1；否则返回 0。
  - 评级 2，最大操作数 5。
- `fitsBits(x, n)`: 
  - 如果 x 可以表示为一个 n 位的补码整数（1 ≤ n ≤ 64），则返回 1。
  - 评级 2，最大操作数 15。
- `rotateLeft(x, n)`: 
  - 将 x 向左旋转 n 位。
  - 评级 3，最大操作数 25。
- `bitParity(x)`: 
  - 如果 x 包含奇数个 0，则返回 1。
  - 评级 4，最大操作数 22。

### 3.2 二进制补码算术 (Two’s Complement Arithmetic)

此部分描述了一组利用二进制补码表示整数的函数。所有参数和返回值均为 `long` 类型。有关更多信息，请参考 `bits.c` 中的注释和 `tests.c` 中的参考版本。

**算术函数**：

- `trueFiveEighths(x)`: 
  - 以避免由于溢出而导致的错误，将 x 乘以 5/8，并向 0 取整。
  - 评级 4，最大操作数 20。
- `addOK(x, y)`: 
  - 确定是否可以在不溢出的情况下计算 x+y。
  - 评级 3，最大操作数 20。
- `isPower2(x)`: 
  - 如果 x 是 2 的幂，则返回 1；否则返回 0。
  - 评级 3，最大操作数 20。
- `isPalindrome(x)`: 
  - 如果 x 中的位模式等于其镜像，则返回 1。
  - 评级 4，最大操作数 70。
- `absVal(x)`: 
  - 返回 x 的绝对值。
  - 评级 4，最大操作数 10。

# 4 评分

你的成绩将根据以下分布计算，总共55分：

- **代码正确性**: 33分。
- **代码性能**: 22分，基于每个函数中使用的运算符数量。

项目中包括一些自动评分工具：

1. `btest`
   1. `btest` 程序通过多次使用不同的参数值调用 `bits.c` 中的函数来检查函数的正确性。
   2. 要构建并使用它，输入以下两个命令：
      1. `linux> make`
      2. `linux> ./btest`
   3. 注意，每次修改 `bits.c` 文件后，你都必须重新构建 `btest`。
   4. 你可以使用 `-f` 标志指示 `btest` 仅测试单个函数。
      1. 例如：`linux> ./btest -f copyLSB`
      2. 你可以使用选项标志 `-1 -2 -3` 分别为前三个函数参数提供特定的参数值。
2. `dlc`
   1. `dlc` 程序检查每个谜题是否符合编码规则。如果程序检测到问题（如非法操作符、操作符过多或整数谜题中的非直线型代码），它将打印错误。
   2. 使用 `-e` 开关运行 `dlc` 会打印每个函数使用的操作符数量。
      1. 例如：`linux> ./dlc -e bits.c`
3. BDD 检查器
   1. `btest` 程序仅针对多种不同情况测试你的函数。对于大多数函数，可能的参数组合远远超出了可以详尽测试的范围。为了提供完整的覆盖，我们创建了一个名为 `cbit` 的正式验证程序，它通过使用称为二进制决策图 (BDD) 的数据结构，详尽地测试你的函数的所有可能的参数组合。
   2. 你不能直接调用 `cbit`。相反，有一系列 Perl 脚本设置并评估对它的调用。要检查你所有的函数并获得紧凑的表格式结果摘要，执行：
      1. `linux> ./bddcheck/check.pl -g`
4. `driver.pl`
   1. 这是一个驱动程序，使用 `dlc` 和 BDD 检查器来计算你的解决方案的正确性和性能分数。这与 Autolab 在自动评分你的作业时使用的程序相同。要检查你所有的函数，执行：
      1. linux> ./driver.pl
5. 代码风格
   1. 这个实验室不会对样式进行评分。你在 Autolab 上收到的分数将是你的最终分数。由于 `bits.c` 是唯一上传的文件，Autolab 不会对这个实验室强制执行格式化规则。
   2. 与 Lab 0 一样，我们为你提供了 clang-format 工具来帮助你格式化代码。要调用它，运行 `make format`。你可以修改 `.clang-format` 文件以反映你首选的代码风格。更多信息可在 http://www.cs.cmu.edu/~213/codeStyle.html 查看。

**关于使用自动评分工具需要注意的几点问题**：

- `dlc` 程序不是一个完整的C编译器：
  - **不要在 `bits.c` 文件中包含任何头文件**：标准C库头文件（例如 `stdio.h`）通常包含 `dlc` 无法理解的代码。为了调试，`printf` 已经在 `bits.c` 文件的顶部手动声明，因此你可以在不包含 `stdio.h` 的情况下使用它。
  - **调用 `printf`（像任何其他函数调用一样）都是违反编码规则的**：在手动测试代码或使用 `btest` 测试时，你可以放置调试 `printf`，但在提交作业之前，以及在使用 `driver.pl`、`dlc` 或 `bddcheck/check.pl` 测试之前，你需要再次移除它们。
- BDD检查器也不是一个完整的C编译器，它有更多的怪癖：
  - **在使用BDD检查器之前，请确保你的代码已编译**（使用 `make`）。如果提供了格式错误的代码，BDD检查器不会提供很好的错误信息。
  - **BDD检查器无法处理调用其他函数的函数**，包括 `printf`。你应该使用 `btest` 来评估带有调试 `printf` 语句的代码。在提交代码之前，请确保移除这些调试语句。
  - 当 `bddcheck/check.pl` 报告语法错误时该怎么办
    - `bddcheck/check.pl` 报告的语法错误是从函数的第一行开始索引的，而不是从文件的第一行！这可能会令人困惑。
    - BDD检查器脚本对函数的格式有些挑剔。它们期望函数以以下形式之一开头：`long fun (...)` 或 `unsigned fun (...)`。
    - 它们还期望函数以其闭合大括号在单独一行结束，并且之前没有任何空白。
    - 如果你注释掉部分代码，请确保使用 `//` 明确注释掉每个函数的第一行，而不是依赖于 `/*` 和 `*/` 的块注释。

# 5 调试建议

以下是推荐的步骤：
1. **Step 1**：使用 `btest` 测试和调试一个函数。首先，使用 `-1` 参数结合 `-f` 来调用一个特定的函数和输入参数：
   ```
   linux> ./btest -f copyLSB -1 7
   ```
   你可以使用 `printf` 语句显示中间变量的值。但在调试完成后要小心移除它们。
2. **Step 2**：使用 `btest -f` 检查你的函数针对大量不同输入值的正确性：
   
   ```
   linux> ./btest -f copyLSB
   ```
   如果 `btest` 检测到错误，它会打印出失败的特定输入参数。返回到第一步，使用这些参数调试你的函数。
3. **Step 3**：使用 `dlc` 检查你是否遵守了编码规则：
   ```
   linux> ./dlc bits.c
   ```
4. **Step 4**：在你的函数通过了 `btest` 的所有测试后，使用 BDD 检查器进行最终的正确性测试：
   
   ```
   linux> ./bddcheck/check.pl -f copyLSB
   ```
5. **Step 5**：重复第1-4步骤，针对每个函数。你可以随时通过运行驱动程序`driver.pl`来计算你所获得的总正确性和性能分数：
   
   ```
   linux> ./driver.pl
   ```

